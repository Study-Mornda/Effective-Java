# Item16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

## 데이터 캡슐화하기

데이터 모으기만 하는 아무 목적 없는 퇴보한 클래스는 **필드가 public이어서는 안 된다.**
```java
class Point{
    public double x;
    public double y;
}
```
문제점
- 데이터 필드에 직접 접근할 수 있으니 캡슐화의 이점을 제공하지 못한다.
- API를 수정하지 않고는 내부 표현을 바꿀 수 없고(필드가 수정되면 API도 수정되니까. 곧 `필드=API`),   
  불변식을 보장할 수 없으며(외부에서 값이 계속 수정되므로),   
  외부에서 필드에 접근할 때 부수 작업(값을 검증한다던가, 다른 메서드를 수행하다던가..)을 수행할 수도 없다.
  

대안
- 모든 필드를 public -> private 으로 바꾸고 대신 public 접근자(getter)를 추가한다.

## public 클래스
public 클래스라면 위 방법을 사용하는게 적절하다.   
패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공해서 **클래스 내부 표현 방식은 보호할 수 있어야한다.**
만약 그렇지 못하고 필드를 제공할 경우 개발자가 내부 표현 방식을 마음대로 바꿀 수 없게 된다.  
(마치 client 권한 제한)

## package-private 클래스 및 private 중첩 클래스
> private 중첩 클래스: 한 클래스 내에서만 사용하는 클래스인 경우 중첩해서 사용한다.

여기선 데이터 필드를 노출해도 어떤 문제도 없다. 그 클래스가 표현하려는 추상 개념만 올바르게 표현해주면 된다.

특징
- 클래스 선언 및 이를 사용하는 클라이언트 코드에선 **접근자 방식보다 훨씬 깔끔하다.**
- 클라이언트 코드가 이 클래스 내부 표현에 묶이기는 함(필드명, 타입 바뀔 때마다 클라이언트 코드 수정해야된다는 뜻).
- But, **클라이언트도 어차피 이 클래스를 포함하는 패키지 안에서만 동작하는 코드일 뿐**. 따라서 패키지 바깥 코드는 전혀 손대지 않고도 데이터 표현 방식을 바꿀 수 있다(패키지 끼리는 독립적이니까 패키지 내부끼리는 내부 표현 바꿔도 외부에 영향이 없다는 뜻).

## 자바 플랫폼 라이브러리에서 규칙 어긴 사례
Point, Dimension

```java
public final class Time{
    private static final int HOURS_PER_DAY    =24;
    private static final int MINUTES_PER_HOUR =60;
    
    public final int hour;      //<-여기
    public final int minute;    //<-여기
    
    //...
}
```
분석
- public 클래스의 필드가 불변이라면 public 접근일 때의 단점이 조금은 줄어든다.
- But, 그래도 API를 변경하지 않고는 표현 방식을 바꿀 수 없다.
- 필드를 읽을 때 부수 작업도 수행할 수 없다.



