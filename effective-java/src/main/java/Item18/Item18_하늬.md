# Item18. 상속보다는 컴포지션을 사용하라

## 상속(extend)에 관하여
상속이 안전한 경우
1. 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면
2. 확장할 목적으로 설계됐고 문서화도 잘 된 클래스라면

상속이 위험한 경우
1. 패키지 경계를 넘어, 즉 다른 패키지의 구체 클래스를 상속하는 일은 위험

상속이 위험한 이유
- 상위 클래스가 어떻게 구현되는지에 따라 하위 클래스의 동작에 이상이 생길 수 있다. (ex. 릴리즈마다 내부 구현 달라짐)
- 따라서 상위 클래스 설계자가 확장을 충분히 고려, 문서화도 제대로 해야 상속이 안전하다. 아니면 상위 클래스에 발맞춰 수정돼야한다.

## 상속이 위험한 예시
> 아래는 HashSet 예시를 간략화함. `카운트`는 원소 개수를 의미함.
```
public class InstrumentedHashSet<E> extends HashSet<E>{
	//...
	private int 카운트=0;

	@Override ..add(E e){
		// 카운트+1
		return super.add(e);
	}
	@Override ..addAll(Collection<? extends E> c) {
		// c원소 개수 카운트 함.
		return super.addAll(c)
	}
}
```
Problem) addAll메서드로 원소 3개를 추가하면 카운트=3일 것 같지만 실제론 6이다.
- 원인: 내부적으로 HashSet(=super class)의 addAll 메서드가 add 메서드를 사용함. **이때 add는 구현클래스의 메서드.** 따라서 원소 하나당 카운트가 2씩 늘어났기 때문

**Point) HashSet의 기능을 일부 override하면서 카운트 기능도 사용하려면 어떻게 해야하는가?**

Sol1) 하위 클래스에서 addAll 메서드를 재정의하지 않는다.
- 문제 : HashSet의 addAll이 add 메서드를 이용해 구현했음을 가정한 것이라 언제든 가정에 위배될 수 있다. (자기 사용)

Sol2) HashSet의 addAll 사용하는 대신 원소 하나당 add메서드를 쓴다.
- 문제: 상위클래스의 메서드 동작을 다시 구현해야한다.

Sol3) 메서드 재정의 대신 새로운 메서드를 추가한다.
- 문제: 훨씬 안전하지만(1,2에 비해) 상위 클래스에 운 나쁘게 하필 내가 추가한 메서드와 시그니처가 같다면 앞과 같은 문제로 돌아옴.
  > 반환 타입만 다르다면: 컴파일조차 안될것  
    반환 타입조차 같으면: 새 메서드를 정의한 꼴이니 앞과 같은 문제로 돌아옴.


## 해결 방안
기존 클래스를 확장하는 대신, **새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 한다.**  
=> 이걸 우린 `컴포지션`이라 함

새 클래스의 인스턴스 메서드는 기존 클래스에 대응하는 메서드를 호출해 그 결과를 반환함.(약간 대변인 처럼.)   
=> 이걸 우린 `전달(forwarding)`이라 함

여기서 새 클래스의 메서드들을   
=> `전달 메서드(forwarding method)`라 함

`컴포지션`과 `전달`을 사용했을 때 이점 정리
- 새로운 클래스는 기존 클래스의 내부 구현이 어떤든 영향받지 않는다.
- 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향 받지 않는다.


**임의의 Set에 추가 기능을 덧씌워 새로운 Set으로 만든 것이 핵심**
```
// 래퍼 클래스. 상속대신 컴포지션 사용
public class InstumentedSet<E> extends ForwardingSet<E>{
	...
	public InstumentedSet(Set<E> s) {
		super(s);
	}
}

// HashSet의 모든 기능을 직접 Set을 implement해서 정의했다.
// 재사용할 수 있는 전달 클래스.
public class ForwardingSet<E> implements Set<E> {
	private final Set<E> s;
	public ForwardingSet(Set<E> s) {
		this.s = s;
	}
	//..
}
```

## 상속 vs 컴포지션
상속
- 구체 class 각각을 따로 확장해야함(필요한 만큼)
- super class의 생성자 각각에 대응하는 생성자 많이 만들어야됨

컴포지션
- 한번만 구현해두면 어떤 Set구현체라도 추가 기능 사용 가능.

InstumentedSet처럼 다른 Set클래스를 감싸고 있는 클래스를  
=> `래퍼 클래스`라 함  
다른 Set에 추가 기능을 덧씌운다는 뜻에서   
=> `데코레이터 패턴`이라고 한다.  

> 래퍼 클래스는 콜백 프레임워크와는 어울리지 않으니 주의해야한다.  
-> 콜백 프레임워크에선 자기 자신의 참조를 다른 객체에 넘기는데, 내부 객체는 자신을 감싸고 있는 래퍼의 존재를 모르니 **자신의 참조**를 넘겨서 콜백 때는 래퍼가 아닌 **내부 객체**를 호출하기 때문  
=> 이걸 우린 `SELF 문제`라고 함.

## 정리 및 주의
- 상속은 B is-a A일 때만 A를 상속해라 (하위클래스가 진짜 하위 클래스라는 확신이 있을 때)
	> 아니라면 <A를 private 인스턴스로 두고> <A와는 다른 API를 제공해야한다>. 결국 A는 구현하는 하나의 방법이었을 뿐 맥락이 맞지 않다는 얘기

- 컴포지션을 써야할 때 상속을 쓴다? -> 내부 구현이 api에 영향을 미친다.

- 내가 확장하려는 클래스의 api에 아무런 결함이 없는가?
    > 있다면 이 결함이 내 클래스의 api까지 전파돼도 되는가?  
	  - 컴포지션은 결함 숨기기 가능  
	  - 상속은 .. 불가능


