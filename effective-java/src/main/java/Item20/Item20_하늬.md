# 추상 클래스보다는 인터페이스를 우선하라

## 추상 클래스, 인터페이스 비교
> 둘 다 인스턴스 메서드를 구현 형태로 제공할 수 있다.

추상 클래스
- 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 돼야함(계층 구조) => 새로운 타입을 정의하는 데 커다란 제약
- 기존 클래스 위에 새로운 추상 클래스를 끼워넣기 어렵다.
- 믹스인을 정의할 수 없다. 기존 클래스에 덧씌울 수 없기 때문
- 계층 구조를 가지므로 조합 폭발을 야기한다.
  > 조합 폭발: a->b->c의 계층이면 a가 b또는 c 또는 b,c 모두를 구현하는 메서드, 생성자를 구현해야한다. 이런 식으로 n개의 속성 조합을 따졌더니 2^n개가 되며 구현해야될 수가 폭발하는 현상.

인터페이스
- 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.
- 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.
- 믹스인의 정의와 잘 맞다. 클래스가 잘 구현할 수 있는 타입이라는 뜻. 즉, 믹스인을 구현하면 원래 클래스의 '주된 타입' 외에도 특ㅈ겅 선택적 행위를 제공할 수 있다.
- 계층구조가 없는 타입 프레임워크를 만들 수 있음.(확장성)


## 인터페이스 활용
- 인터페이스의 메서드 중 구현 방법이 명백한 것이 있으면 그 구현을 디폴트 메서드로 제공해 일을 덜 수 있다.
  > 디폴트 메서드는 상속하는 사람을 위해 `@implSpec` 태그로 문서화해야한다.
  > **equals, hashCode는 디폴트 메서드로 제공해선 안된다.**
- 추상골격구현 클래스를 활용한다.
  * 인터페이스로는 타입 정의 + 디폴트 메서드
  * 나머지 메서드들까지 골격 구현 클래스가 구현  
  => 이걸 우린 `템플릿 메서드 패턴`으로 부른다.
  * 명명: 관례상 인터페이스 이름 앞에 `Abstract`를 붙인다.

## 골격구현클래스 진가
추상 클래스처럼 구현을 도와주는 동시에, 추상 클래스로 타입을 정의할 때 따라오는 심각한 제약에선 자유롭다.

이렇게 하기 어렵다면..
- 골격 구현을 확장하지 못한다면 -> 인터페이스를 직접 구현하되 디폴트 메서들의 이점을 누릴 수 있다.
- 우회적으로 인터페이스를 구현한 클래스에서 해당 골격 구현을 확장한 private 내부 클래스를 정의하고, 각 메서드 호출을 내부 클래스의 인스턴스에 전달하는 것이다. (아래 Item 18과 비교)

```
public class Foo implements Imp {

	priavate GoAbstractImp goAbstractImp; // 추상골격클래스의 구현체
}

public class Foo {
	private Bar bar; // Item18 중 컴포지션
}
```
